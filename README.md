## GigaChat + Function Calling (Notebook)

Коротко: этот ноутбук демонстрирует, как работать с GigaChat и механизмом вызова функций (function calling):
1) получаем `access_token` через SDK `gigachat`,
2) отправляем запрос к API `chat/completions` с описанием функций,
3) принимаем `function_call` от модели, локально выполняем функцию,
4) отправляем результат обратно в диалог и получаем финальный ответ ассистента.

### Содержание
- Назначение
- Требования и установка
- Подготовка токена авторизации
- Структура ноутбука
- Как запустить
- Как это работает (flow)
- Безопасность и примечания
- Частые проблемы

### Назначение
Показать минимальный рабочий пример интеграции GigaChat с локальным выполнением функций: модель запрашивает вызов функции (например, «получить текущее время»), код выполняет её и возвращает результат в чат.

### Требования и установка
Необходим Python 3.9+ и следующие пакеты:

```bash
pip install gigachat requests urllib3
```

Примечание: в ноутбуке отключена проверка SSL-сертификатов для упрощения демонстрации. Для продакшн-сценариев используйте проверку сертификатов.

### Подготовка токена авторизации
1. Получите ключ/секрет для доступа к GigaChat (переменная `auth_key`).
2. В ноутбуке переменная `auth_key` задаётся вручную в первой ячейке. Рекомендуется вместо этого хранить ключ в переменных окружения и считывать его из `os.environ`.

### Структура ноутбука
- Ячейка 1: импорт `urllib3` и отключение предупреждений (демо).
- Ячейка 2: инициализация `GigaChat(credentials=auth_key, verify_ssl_certs=False)` и получение `access_token`.
- Ячейка 3: пример function calling:
  - Описывается функция `get_current_time` (без параметров, возвращает ISO-время),
  - Отправляется запрос `POST /api/v1/chat/completions` со списком `functions` и `function_call="auto"`,
  - При ответе с `function_call` локально вызывается соответствующая функция и её результат добавляется в диалог,
  - Повторный запрос формирует финальный ответ ассистента.

### Как запустить
1. Откройте `main.ipynb` в Jupyter/VS Code.
2. Установите зависимости (см. раздел «Требования и установка»).
3. Установите `auth_key` в первой ячейке.
4. Запустите все ячейки по порядку.

### Как это работает (flow)
1. Клиент GigaChat получает токен по `auth_key` и сохраняет `access_token`.
2. Отправляем сообщение пользователя и спецификацию функции в `functions`.
3. Модель может вернуть `function_call` с именем функции и аргументами.
4. Код локально выполняет указанную функцию и добавляет её результат в историю сообщений как роль `function`.
5. Второй запрос к API с результатом функции формирует финальный текстовый ответ ассистента.

### Безопасность и примечания
- Никогда не коммитьте реальные ключи/токены в репозиторий.
- По возможности включайте проверку SSL (`verify_ssl_certs=True` и `verify=True` в HTTP-запросах) и используйте валидные сертификаты.
- Ограничивайте набор доступных функций и валидируйте аргументы перед выполнением, чтобы избежать небезопасных действий.

### Частые проблемы
- Неверный или просроченный токен: получите новый `access_token` через SDK.
- 403/401 от API: проверьте `Authorization: Bearer <token>` и права доступа.
- Ошибки SSL: для продакшн окружений настройте корректные сертификаты и включите проверку.

### Полезно знать
- Эндпоинт: `https://gigachat.devices.sberbank.ru/api/v1/chat/completions`
- Ключевые поля запроса: `model`, `messages`, `functions`, `function_call`.
- В демо-функции `get_current_time` параметры не требуются; ответ возвращается как строка ISO.


